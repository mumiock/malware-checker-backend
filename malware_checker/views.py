from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import dns.resolver
from .helpers.get_malicious import hostname, ip, url, file
import hashlib
from .helpers.otx_class import otx
import json
from .models import PastQuery
from django.utils.timezone import now, timedelta
from django.db.models import Count
from django.db.models import Case, When, Value, IntegerField
from django.forms.models import model_to_dict
from django.db.models.functions import TruncDate
# Create your views here.

@csrf_exempt
def dns_lookup(request):
    if request.method == 'POST':
        try:
           
            request_data = json.loads(request.body.decode('utf-8'))
            target_domain = request_data.get('target_domain', '')
          
            record_types = ["A", "AAAA", "CNAME", "MX", "NS", "SOA", "TXT"]

            resolver = dns.resolver.Resolver()
            
            result_data = {}
     
            for record_type in record_types:
                try:
                    answers = resolver.resolve(target_domain, record_type)
                except Exception as e:
                    continue

                result_data[record_type] = [str(rdata) for rdata in answers]
            
            response_data = {
                'success': True,
                'message': f'DNS lookup for {target_domain} successful',
                'data': result_data,
            }
            
            return JsonResponse(response_data)
        except Exception as e:
            error_data = {
                'success': False,
                'message': f'Error: {str(e)}',
            }
            return JsonResponse(error_data, status=500)
    else:
        error_data = {
            'success': False,
            'message': 'Invalid request method. Only POST requests are allowed.',
        }
        return JsonResponse(error_data, status=400)


@csrf_exempt
def otx_lookup(request):
    if request.method == 'POST':
        try:
            args = json.loads(request.body.decode('utf-8'))

            if 'ip' == args['inputType']:
                alerts = ip(otx, args['inputData'])
            elif 'host' == args['inputType']:
                alerts = hostname(otx, args['inputData'])
            elif 'url' == args['inputType']:
                alerts = url(otx, args['inputData'])
            elif 'hash' == args['inputType']:
                alerts = file(otx, args['inputData'])
            elif 'file' == args['inputType']:
                file_path = args['inputData']
                file_hash = hashlib.md5(open(file_path, 'rb').read()).hexdigest()
                alerts = file(otx, file_hash)
            else:
                response_data = {
                    'success': False,
                    'message': 'Invalid parameters. Provide at least one of: ip, host, url, hash, or file.',
                }
                return JsonResponse(response_data, status=400)

            if alerts[0].get('malicious') == True:
                query = PastQuery (
                    query_text=str(args),
                    malicious= True,
                    dns_enumeration_result=str(alerts),
                    api_response=str(alerts[-1].get('result')),
                    created_at= now()
                )
                query.save()
                response_data = {
                    'success': True,
                    'message': 'Identified as potentially malicious',
                    'data': model_to_dict(query),
                }
             
            else:
                query = PastQuery (
                    query_text=str(args),
                    malicious= False,
                    dns_enumeration_result=str(alerts),
                    api_response=str(alerts[-1].get('result')),
                    created_at= now()
                )
                query.save()
                response_data = {
                    'success': True,
                    'message': 'Unknown or not identified as potentially malicious',
                    'data': model_to_dict(query),
                }

            return JsonResponse(response_data)
        except Exception as e:
            error_data = {
                'success': False,
                'message': f'Error: {str(e)}',
            }
            return JsonResponse(error_data, status=500)
    else:
        error_data = {
            'success': False,
            'message': 'Invalid request method. Only POST requests are allowed.',
        }
        return JsonResponse(error_data, status=400)

@csrf_exempt
def doughnut_chart_data(request):
    try:

        last_50_queries = PastQuery.objects.order_by('-created_at')[:50]

        labels = ["malicious", "not malicious", "not known"]
        data_values = [0, 0, 0]
        background_colors = ["#ff6384", "#36a2eb", "#ffce56"]
        hover_background_colors = ["#ff6384", "#36a2eb", "#ffce56"]

        for query in last_50_queries:
            if query.malicious:
                data_values[0] += 1  # Malicious
            elif query.malicious is False:
                data_values[1] += 1  # Not malicious
            else:
                data_values[2] += 1  # Not known

        doughnut_chart_data = {
            'labels': labels,
            'datasets': [
                {
                    'data': data_values,
                    'backgroundColor': background_colors,
                    'hoverBackgroundColor': hover_background_colors,
                },
            ],
        }

        return JsonResponse({'doughnutChartData': doughnut_chart_data})

    except Exception as e:
        error_data = {
            'success': False,
            'message': f'Error: {str(e)}',
        }
        return JsonResponse(error_data, status=500)
    
@csrf_exempt
def line_chart_data(request):
    try:
        start_date = now() - timedelta(days=6)
        daily_counts = (
            PastQuery.objects
            .filter(created_at__gte=start_date)
            .filter(malicious=True)
            .annotate(day=TruncDate('created_at'))
            .values('day')
            .annotate(total_count=Count('id'))
            .order_by('day')
        )
        
        daily_counts_dict = {daily_count['day'].strftime('%B %d'): daily_count['total_count'] if 'total_count' in daily_count else 0 for daily_count in daily_counts}
        labels = [start_date.strftime('%B %d') for start_date in (now() - timedelta(days=i) for i in range(6, -1, -1))]
        data_values = [daily_counts_dict.get(label, 0) for label in labels]
        line_chart_data = {
            'labels': labels,
            'datasets': [
                {
                    'label': 'Malicious Data',
                    'data': data_values,
                    'backgroundColor': 'rgba(255, 99, 132, 0.2)',
                    'borderColor': 'rgba(255, 99, 132, 1)',
                    'borderWidth': 1,
                },
            ],
        }

        return JsonResponse({'LineChartData': line_chart_data})

    except Exception as e:
        error_data = {
            'success': False,
            'message': f'Error: {str(e)}',
        }
        return JsonResponse(error_data, status=500)
    
@csrf_exempt
def get_logs(request):
    try:

        request_data = json.loads(request.body.decode('utf-8'))
        log_count = int(request_data.get('log_count', 0))

        logs_queryset_lenght = int(len(PastQuery.objects.order_by('-created_at')))

        if logs_queryset_lenght > 50:
            logs_queryset = PastQuery.objects.order_by('-created_at')[log_count:log_count+50]
        else:
            logs_queryset = PastQuery.objects.order_by('-created_at')[log_count:logs_queryset_lenght]

        logs_data = []

        for log in logs_queryset:

            if log.malicious == True:
                color = "#ff0000"
            elif log.malicious == False:
                color = "#008000"
            else:
                color = "#FFEA00" # Default color

            json_data = json.loads(log.query_text.replace("'", "\""))

            logs_data.append({
                'type': json_data['inputType'],
                'data': json_data['inputData'],
                'time': log.created_at.strftime('%H:%M'),
                'color': color,
                'key': log.id,
                'code': str(log.api_response),

            })

        return JsonResponse({'logs': logs_data})

    except Exception as e:
        error_data = {
            'success': False,
            'message': f'Error: {str(e)}',
        }
        return JsonResponse(error_data, status=500)

@csrf_exempt
def get_more_logs(request):
    try:

        request_data = json.loads(request.body.decode('utf-8'))
        begin_log_count = int(request_data.get('begin_log_count', 0))
        end_log_count = int(request_data.get('end_log_count', 15))

        logs_queryset_lenght = int(len(PastQuery.objects.order_by('-created_at')))
        logs_data = []
        if logs_queryset_lenght > 50:
            logs_queryset = PastQuery.objects.order_by('-created_at')[begin_log_count:end_log_count]
        else:
            return JsonResponse({'logs': logs_data})

        for log in logs_queryset:

            if log.malicious == True:
                color = "#ff0000"
            elif log.malicious == False:
                color = "#008000"
            else:
                color = "#FFEA00" # Default color

            json_data = json.loads(log.query_text.replace("'", "\""))

            logs_data.append({
                'type': json_data['inputType'],
                'data': json_data['inputData'],
                'time': log.created_at.strftime('%H:%M'),
                'color': color,
                'key': log.id,
                'code': str(log.api_response),
            })

        return JsonResponse({'logs': logs_data})

    except Exception as e:
        error_data = {
            'success': False,
            'message': f'Error: {str(e)}',
        }
        return JsonResponse(error_data, status=500)